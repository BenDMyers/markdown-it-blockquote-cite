{"version":3,"sources":["node_modules/browser-pack/_prelude.js","index.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"markdown-it-attribution.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","module.exports = function attributionPlugin (md, options) {\n  /**\n   * A regular expression matching common URL patterns.\n   *\n   * @see {@link https://mathiasbynens.be/demo/url-regex}\n   *\n   * @type {RegExp}\n   */\n  var REGEX_URL = /https?:\\/\\/[^\\s/$.?#()].[^\\s()]*/i;\n\n  /**\n   * An enumeration of token types.\n   *\n   * @type {Object<string,string>}\n   */\n  var TokenType = {\n    BLOCKQUOTE_OPEN: 'blockquote_open',\n    BLOCKQUOTE_CLOSE: 'blockquote_close'\n  };\n\n  /**\n   * Default options of the parser plugin.\n   *\n   * @type {Object}\n   */\n  var Defaults = {\n    classNameContainer: 'c-blockquote',\n    classNameAttribution: 'c-blockquote__attribution',\n    marker: 'â€”', // EM dash\n    removeMarker: true,\n  };\n\n  /**\n   * Copy the values of all enumerable own properties from a source object to a\n   * target object.\n   *\n   * @type {Function}\n   */\n  var assign = md.utils.assign;\n\n  /**\n   * Prepare the plugin options and merge user options with the defauls.\n   *\n   * @type {Object}\n   */\n  options = assign({}, Defaults, options);\n\n  /**\n   * Determine whether the given value is an integer.\n   *\n   * @param {*} value The value to inspect.\n   * @return {Boolean}\n   */\n  function isInteger (value) {\n    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n  }\n\n  /**\n   * Determine whether a given string is empty.\n   *\n   * @param {string} str The string to inspect.\n   * @return {Boolean}\n   */\n  function isEmpty (str) {\n    return !str || (str.length === 0) || (str.trim().length === 0);\n  }\n\n  /**\n   * Extract an url from the given string.\n   *\n   * @param {string} str The string to extract an url from.\n   * @return {string}\n   */\n  function extractUrl (str) {\n    var matches = str.match(REGEX_URL);\n    return matches !== null\n      ? matches.shift()\n      : null;\n  }\n\n  /**\n   * Determines whether a string begins with the characters of a another string.\n   *\n   * @param {string} str The string to inspect.\n   * @param {string} needle The string to search for.\n   * @return {Boolean}\n   */\n  function startsWith (str, needle) {\n    return str.slice(0, needle.length) === needle;\n  }\n\n  /**\n   * Remove whitespace from the beginning of a string.\n   *\n   * @param {string} str The string to trim.\n   * @return {string}\n   */\n  function trimStart (str) {\n    return str.replace(/^\\s+/, '');\n  }\n\n  /**\n   * Remove whitespace from the end of a string.\n   *\n   * @param {string} str The string to trim.\n   * @return {string}\n   */\n  function trimEnd (str) {\n    return str.replace(/\\s+$/, '');\n  }\n\n  /**\n   * Insert multiple items at the given index position.\n   *\n   * @param {Array} array The array to add items to.\n   * @param {Object[]} items One or multiple items to add.\n   * @param {Number} position The index position at which to add the items.\n   */\n  function insertAt (array, items, position) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      array.splice(position + i, 0, items[i]);\n    }\n  }\n\n  /**\n   * Remove all items between the given indices.\n   *\n   * @param {Array} array The array to remove items from.\n   * @param {Number} [from=0] The index to start from.\n   * @param {Number} [to=array.length-1] The index at which to stop deletion.\n   * @return {Number}\n   */\n  function remove (array, from, to) {\n    from = isInteger(from) ? from : 0;\n    to = isInteger(to) ? to : array.length - 1;\n\n    var amount = to - from;\n    var items = array.splice(from, amount);\n\n    return items.length;\n  }\n\n  /**\n   * Determine whether the given object has equal property values.\n   *\n   * @param {Object} obj The object to inspect.\n   * @param {Object} props The collection of property values to test.\n   * @return {Boolean}\n   */\n  function matches (obj, props) {\n    for (var prop in props) {\n      if (props.hasOwnProperty(prop) && (props[prop] !== obj[prop])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Find the index of the first token that has equal property values.\n   *\n   * @param {MarkdownIt.Token[]} tokens A token stream to search within.\n   * @param {Object<string,*>} props A collection of key<->value pairs to match against.\n   * @param {Number} [position=0] The start index to start searching from.\n   * @return {Number}\n   */\n  function findToken (tokens, props, position) {\n    position = isInteger(position) ? position : 0;\n\n    for (var i = position, l = tokens.length; i < l; i++) {\n      if (matches(tokens[i], props)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Find the index position of a given marker in a string.\n   *\n   * NOTE: An attribution marker either has to be the first character of a\n   * string or it has to be immediately following a soft break/line break.\n   *\n   * @param {string} str The string to search within.\n   * @param {string} marker The marker to search for.\n   * @return {Number}\n   */\n  function findMarker (str, marker) {\n    // Return early if the paragraph starts with the marker.\n    if (startsWith(str, marker)) {\n      return 0;\n    }\n\n    // Search for the marker following a soft break.\n    var length = marker.length;\n    var position = str.indexOf('\\n' + marker, length + 1);\n\n    return (position > length) ? position + 1 : -1;\n  }\n\n  /**\n   * Find a attribution line within the given range.\n   *\n   * @param {MarkdownIt.Token[]} tokens The token stream to search.\n   * @param {string} marker The character code of the attribution marker.\n   * @param {Number} [level=0] The level of the block quote.\n   * @param {Number} [from=0] The index position to start searching from.\n   * @param {Number} [to=tokens.length-1] The upper boundary to stop searching.\n   * @return {Number}\n   */\n  function findAttribution (tokens, marker, level, from, to) {\n    level = isInteger(level) ? level : 0;\n    from = isInteger(from) ? from : 0;\n    to = isInteger(to) ? to : tokens.length;\n\n    for (var i = from; i < to; i++) {\n      var token = tokens[i];\n      var content = token.content;\n\n      if ((token.type !== 'inline') || (token.level !== level + 2) || (content.length === 0)) {\n        continue;\n      }\n\n      var position = findMarker(content, marker);\n\n      if (position !== -1) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Attribution Rule\n   *\n   * Improve the generated HTML markup for block quotes with proper attribution\n   * syntax.\n   *\n   * @param {MarkdownIt.StateCore} state The current state of the parser.\n   * @return {void}\n   */\n  function rule (state) {\n    var tokens = state.tokens;\n\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      // Find the opening tag of the next blockquote.\n      var start = findToken(tokens, { type: TokenType.BLOCKQUOTE_OPEN }, i);\n\n      if (start === -1) {\n        continue;\n      }\n\n      // Find the closing tag of the current block quote.\n      var level = tokens[start].level;\n      var end = findToken(tokens, { type: TokenType.BLOCKQUOTE_CLOSE, level: level }, start + 1);\n\n      /* istanbul ignore if */\n      if (end === -1) {\n        continue;\n      }\n\n      // Find the attribution line of the current block quote.\n      var position = findAttribution(tokens, options.marker, level, start + 1, end);\n\n      if (position === -1) {\n        continue;\n      }\n\n      // Increase the level of each block quote token as it will be wrapped in a\n      // container element.\n      for (var j = start; j <= end; j++) {\n        tokens[j].level++;\n      }\n\n      // Remove the attribution line from the rest of the paragraph.\n      var token = tokens[position];\n      var source = token.content;\n      var index = findMarker(source, options.marker);\n\n      var content = (index > 0) ? trimEnd(source.slice(0, index)) : null;\n      var attribution = (index > 0) ? source.slice(index) : source;\n\n      token.content = content;\n\n      // Remove the paragraph tokens from the stream, if no content is left.\n      if (isEmpty(content)) {\n        end -= remove(tokens, position - 1, position + 2);\n      }\n\n      // Use any url found in the attribution line as the cite attribute.\n      var blockquoteOpen = tokens[start];\n      var url = extractUrl(attribution);\n\n      if (!isEmpty(url)) {\n        blockquoteOpen.attrSet('cite', url);\n      }\n\n      // Create new tokens for the attribution line.\n      var captionOpen = new state.Token('blockquote_attribution_open', 'figcaption', 1);\n      captionOpen.block = true;\n      captionOpen.level = level + 1;\n\n      var caption = new state.Token('inline', '', 0);\n      caption.children = [];\n      caption.level = level + 2;\n      caption.content = options.removeMarker\n        ? trimStart(attribution.slice(options.marker.length))\n        : attribution;\n\n      var captionClose = new state.Token('blockquote_attribution_close', 'figcaption', -1);\n      captionClose.block = true;\n      captionClose.level = level + 1;\n\n      if (!isEmpty(options.classNameAttribution)) {\n        captionOpen.attrSet('class', options.classNameAttribution);\n      }\n\n      insertAt(tokens, [captionOpen, caption, captionClose], end + 1);\n\n      // Wrap block quote and attribution in a figure element.\n      var figureOpen = new state.Token('blockquote_container_open', 'figure', 1);\n      figureOpen.block = true;\n      figureOpen.level = level;\n\n      var figureClose = new state.Token('blockquote_container_close', 'figure', -1);\n      figureClose.block = true;\n      figureClose.level = level;\n\n      if (!isEmpty(options.classNameContainer)) {\n        figureOpen.attrSet('class', options.classNameContainer);\n      }\n\n      insertAt(tokens, [figureClose], end + 4);\n      insertAt(tokens, [figureOpen], start);\n\n      // Skip the generated block quote tokens in the stream.\n      i = end + 5;\n    }\n  }\n\n  md.core.ruler.after('block', 'attribution', rule);\n};\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdHRyaWJ1dGlvblBsdWdpbiAobWQsIG9wdGlvbnMpIHtcbiAgLyoqXG4gICAqIEEgcmVndWxhciBleHByZXNzaW9uIG1hdGNoaW5nIGNvbW1vbiBVUkwgcGF0dGVybnMuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9kZW1vL3VybC1yZWdleH1cbiAgICpcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gIHZhciBSRUdFWF9VUkwgPSAvaHR0cHM/OlxcL1xcL1teXFxzLyQuPyMoKV0uW15cXHMoKV0qL2k7XG5cbiAgLyoqXG4gICAqIEFuIGVudW1lcmF0aW9uIG9mIHRva2VuIHR5cGVzLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxzdHJpbmc+fVxuICAgKi9cbiAgdmFyIFRva2VuVHlwZSA9IHtcbiAgICBCTE9DS1FVT1RFX09QRU46ICdibG9ja3F1b3RlX29wZW4nLFxuICAgIEJMT0NLUVVPVEVfQ0xPU0U6ICdibG9ja3F1b3RlX2Nsb3NlJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IG9wdGlvbnMgb2YgdGhlIHBhcnNlciBwbHVnaW4uXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgRGVmYXVsdHMgPSB7XG4gICAgY2xhc3NOYW1lQ29udGFpbmVyOiAnYy1ibG9ja3F1b3RlJyxcbiAgICBjbGFzc05hbWVBdHRyaWJ1dGlvbjogJ2MtYmxvY2txdW90ZV9fYXR0cmlidXRpb24nLFxuICAgIG1hcmtlcjogJ+KAlCcsIC8vIEVNIGRhc2hcbiAgICByZW1vdmVNYXJrZXI6IHRydWUsXG4gIH07XG5cbiAgLyoqXG4gICAqIENvcHkgdGhlIHZhbHVlcyBvZiBhbGwgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBmcm9tIGEgc291cmNlIG9iamVjdCB0byBhXG4gICAqIHRhcmdldCBvYmplY3QuXG4gICAqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIHZhciBhc3NpZ24gPSBtZC51dGlscy5hc3NpZ247XG5cbiAgLyoqXG4gICAqIFByZXBhcmUgdGhlIHBsdWdpbiBvcHRpb25zIGFuZCBtZXJnZSB1c2VyIG9wdGlvbnMgd2l0aCB0aGUgZGVmYXVscy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIG9wdGlvbnMgPSBhc3NpZ24oe30sIERlZmF1bHRzLCBvcHRpb25zKTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc0ludGVnZXIgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIHN0cmluZyBpcyBlbXB0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc0VtcHR5IChzdHIpIHtcbiAgICByZXR1cm4gIXN0ciB8fCAoc3RyLmxlbmd0aCA9PT0gMCkgfHwgKHN0ci50cmltKCkubGVuZ3RoID09PSAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGFuIHVybCBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBleHRyYWN0IGFuIHVybCBmcm9tLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBleHRyYWN0VXJsIChzdHIpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IHN0ci5tYXRjaChSRUdFWF9VUkwpO1xuICAgIHJldHVybiBtYXRjaGVzICE9PSBudWxsXG4gICAgICA/IG1hdGNoZXMuc2hpZnQoKVxuICAgICAgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBiZWdpbnMgd2l0aCB0aGUgY2hhcmFjdGVycyBvZiBhIGFub3RoZXIgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5lZWRsZSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBzdGFydHNXaXRoIChzdHIsIG5lZWRsZSkge1xuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgbmVlZGxlLmxlbmd0aCkgPT09IG5lZWRsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgd2hpdGVzcGFjZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgYSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB0cmltLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiB0cmltU3RhcnQgKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccysvLCAnJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbUVuZCAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgbXVsdGlwbGUgaXRlbXMgYXQgdGhlIGdpdmVuIGluZGV4IHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gYWRkIGl0ZW1zIHRvLlxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBpdGVtcyBPbmUgb3IgbXVsdGlwbGUgaXRlbXMgdG8gYWRkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gVGhlIGluZGV4IHBvc2l0aW9uIGF0IHdoaWNoIHRvIGFkZCB0aGUgaXRlbXMuXG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnRBdCAoYXJyYXksIGl0ZW1zLCBwb3NpdGlvbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhcnJheS5zcGxpY2UocG9zaXRpb24gKyBpLCAwLCBpdGVtc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgaXRlbXMgYmV0d2VlbiB0aGUgZ2l2ZW4gaW5kaWNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlbW92ZSBpdGVtcyBmcm9tLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2Zyb209MF0gVGhlIGluZGV4IHRvIHN0YXJ0IGZyb20uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdG89YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCBhdCB3aGljaCB0byBzdG9wIGRlbGV0aW9uLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmUgKGFycmF5LCBmcm9tLCB0bykge1xuICAgIGZyb20gPSBpc0ludGVnZXIoZnJvbSkgPyBmcm9tIDogMDtcbiAgICB0byA9IGlzSW50ZWdlcih0bykgPyB0byA6IGFycmF5Lmxlbmd0aCAtIDE7XG5cbiAgICB2YXIgYW1vdW50ID0gdG8gLSBmcm9tO1xuICAgIHZhciBpdGVtcyA9IGFycmF5LnNwbGljZShmcm9tLCBhbW91bnQpO1xuXG4gICAgcmV0dXJuIGl0ZW1zLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVhbCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIGNvbGxlY3Rpb24gb2YgcHJvcGVydHkgdmFsdWVzIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBtYXRjaGVzIChvYmosIHByb3BzKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wcykge1xuICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KHByb3ApICYmIChwcm9wc1twcm9wXSAhPT0gb2JqW3Byb3BdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHRva2VuIHRoYXQgaGFzIGVxdWFsIHByb3BlcnR5IHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtNYXJrZG93bkl0LlRva2VuW119IHRva2VucyBBIHRva2VuIHN0cmVhbSB0byBzZWFyY2ggd2l0aGluLlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsKj59IHByb3BzIEEgY29sbGVjdGlvbiBvZiBrZXk8LT52YWx1ZSBwYWlycyB0byBtYXRjaCBhZ2FpbnN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uPTBdIFRoZSBzdGFydCBpbmRleCB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS5cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gZmluZFRva2VuICh0b2tlbnMsIHByb3BzLCBwb3NpdGlvbikge1xuICAgIHBvc2l0aW9uID0gaXNJbnRlZ2VyKHBvc2l0aW9uKSA/IHBvc2l0aW9uIDogMDtcblxuICAgIGZvciAodmFyIGkgPSBwb3NpdGlvbiwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChtYXRjaGVzKHRva2Vuc1tpXSwgcHJvcHMpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBpbmRleCBwb3NpdGlvbiBvZiBhIGdpdmVuIG1hcmtlciBpbiBhIHN0cmluZy5cbiAgICpcbiAgICogTk9URTogQW4gYXR0cmlidXRpb24gbWFya2VyIGVpdGhlciBoYXMgdG8gYmUgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhXG4gICAqIHN0cmluZyBvciBpdCBoYXMgdG8gYmUgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGEgc29mdCBicmVhay9saW5lIGJyZWFrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gc2VhcmNoIHdpdGhpbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmtlciBUaGUgbWFya2VyIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRNYXJrZXIgKHN0ciwgbWFya2VyKSB7XG4gICAgLy8gUmV0dXJuIGVhcmx5IGlmIHRoZSBwYXJhZ3JhcGggc3RhcnRzIHdpdGggdGhlIG1hcmtlci5cbiAgICBpZiAoc3RhcnRzV2l0aChzdHIsIG1hcmtlcikpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmb3IgdGhlIG1hcmtlciBmb2xsb3dpbmcgYSBzb2Z0IGJyZWFrLlxuICAgIHZhciBsZW5ndGggPSBtYXJrZXIubGVuZ3RoO1xuICAgIHZhciBwb3NpdGlvbiA9IHN0ci5pbmRleE9mKCdcXG4nICsgbWFya2VyLCBsZW5ndGggKyAxKTtcblxuICAgIHJldHVybiAocG9zaXRpb24gPiBsZW5ndGgpID8gcG9zaXRpb24gKyAxIDogLTE7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhIGF0dHJpYnV0aW9uIGxpbmUgd2l0aGluIHRoZSBnaXZlbiByYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtNYXJrZG93bkl0LlRva2VuW119IHRva2VucyBUaGUgdG9rZW4gc3RyZWFtIHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmtlciBUaGUgY2hhcmFjdGVyIGNvZGUgb2YgdGhlIGF0dHJpYnV0aW9uIG1hcmtlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtsZXZlbD0wXSBUaGUgbGV2ZWwgb2YgdGhlIGJsb2NrIHF1b3RlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2Zyb209MF0gVGhlIGluZGV4IHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaGluZyBmcm9tLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RvPXRva2Vucy5sZW5ndGgtMV0gVGhlIHVwcGVyIGJvdW5kYXJ5IHRvIHN0b3Agc2VhcmNoaW5nLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBmaW5kQXR0cmlidXRpb24gKHRva2VucywgbWFya2VyLCBsZXZlbCwgZnJvbSwgdG8pIHtcbiAgICBsZXZlbCA9IGlzSW50ZWdlcihsZXZlbCkgPyBsZXZlbCA6IDA7XG4gICAgZnJvbSA9IGlzSW50ZWdlcihmcm9tKSA/IGZyb20gOiAwO1xuICAgIHRvID0gaXNJbnRlZ2VyKHRvKSA/IHRvIDogdG9rZW5zLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgdmFyIGNvbnRlbnQgPSB0b2tlbi5jb250ZW50O1xuXG4gICAgICBpZiAoKHRva2VuLnR5cGUgIT09ICdpbmxpbmUnKSB8fCAodG9rZW4ubGV2ZWwgIT09IGxldmVsICsgMikgfHwgKGNvbnRlbnQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvc2l0aW9uID0gZmluZE1hcmtlcihjb250ZW50LCBtYXJrZXIpO1xuXG4gICAgICBpZiAocG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRyaWJ1dGlvbiBSdWxlXG4gICAqXG4gICAqIEltcHJvdmUgdGhlIGdlbmVyYXRlZCBIVE1MIG1hcmt1cCBmb3IgYmxvY2sgcXVvdGVzIHdpdGggcHJvcGVyIGF0dHJpYnV0aW9uXG4gICAqIHN5bnRheC5cbiAgICpcbiAgICogQHBhcmFtIHtNYXJrZG93bkl0LlN0YXRlQ29yZX0gc3RhdGUgVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHBhcnNlci5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJ1bGUgKHN0YXRlKSB7XG4gICAgdmFyIHRva2VucyA9IHN0YXRlLnRva2VucztcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgLy8gRmluZCB0aGUgb3BlbmluZyB0YWcgb2YgdGhlIG5leHQgYmxvY2txdW90ZS5cbiAgICAgIHZhciBzdGFydCA9IGZpbmRUb2tlbih0b2tlbnMsIHsgdHlwZTogVG9rZW5UeXBlLkJMT0NLUVVPVEVfT1BFTiB9LCBpKTtcblxuICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCB0aGUgY2xvc2luZyB0YWcgb2YgdGhlIGN1cnJlbnQgYmxvY2sgcXVvdGUuXG4gICAgICB2YXIgbGV2ZWwgPSB0b2tlbnNbc3RhcnRdLmxldmVsO1xuICAgICAgdmFyIGVuZCA9IGZpbmRUb2tlbih0b2tlbnMsIHsgdHlwZTogVG9rZW5UeXBlLkJMT0NLUVVPVEVfQ0xPU0UsIGxldmVsOiBsZXZlbCB9LCBzdGFydCArIDEpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIHRoZSBhdHRyaWJ1dGlvbiBsaW5lIG9mIHRoZSBjdXJyZW50IGJsb2NrIHF1b3RlLlxuICAgICAgdmFyIHBvc2l0aW9uID0gZmluZEF0dHJpYnV0aW9uKHRva2Vucywgb3B0aW9ucy5tYXJrZXIsIGxldmVsLCBzdGFydCArIDEsIGVuZCk7XG5cbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEluY3JlYXNlIHRoZSBsZXZlbCBvZiBlYWNoIGJsb2NrIHF1b3RlIHRva2VuIGFzIGl0IHdpbGwgYmUgd3JhcHBlZCBpbiBhXG4gICAgICAvLyBjb250YWluZXIgZWxlbWVudC5cbiAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8PSBlbmQ7IGorKykge1xuICAgICAgICB0b2tlbnNbal0ubGV2ZWwrKztcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBhdHRyaWJ1dGlvbiBsaW5lIGZyb20gdGhlIHJlc3Qgb2YgdGhlIHBhcmFncmFwaC5cbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1twb3NpdGlvbl07XG4gICAgICB2YXIgc291cmNlID0gdG9rZW4uY29udGVudDtcbiAgICAgIHZhciBpbmRleCA9IGZpbmRNYXJrZXIoc291cmNlLCBvcHRpb25zLm1hcmtlcik7XG5cbiAgICAgIHZhciBjb250ZW50ID0gKGluZGV4ID4gMCkgPyB0cmltRW5kKHNvdXJjZS5zbGljZSgwLCBpbmRleCkpIDogbnVsbDtcbiAgICAgIHZhciBhdHRyaWJ1dGlvbiA9IChpbmRleCA+IDApID8gc291cmNlLnNsaWNlKGluZGV4KSA6IHNvdXJjZTtcblxuICAgICAgdG9rZW4uY29udGVudCA9IGNvbnRlbnQ7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgcGFyYWdyYXBoIHRva2VucyBmcm9tIHRoZSBzdHJlYW0sIGlmIG5vIGNvbnRlbnQgaXMgbGVmdC5cbiAgICAgIGlmIChpc0VtcHR5KGNvbnRlbnQpKSB7XG4gICAgICAgIGVuZCAtPSByZW1vdmUodG9rZW5zLCBwb3NpdGlvbiAtIDEsIHBvc2l0aW9uICsgMik7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSBhbnkgdXJsIGZvdW5kIGluIHRoZSBhdHRyaWJ1dGlvbiBsaW5lIGFzIHRoZSBjaXRlIGF0dHJpYnV0ZS5cbiAgICAgIHZhciBibG9ja3F1b3RlT3BlbiA9IHRva2Vuc1tzdGFydF07XG4gICAgICB2YXIgdXJsID0gZXh0cmFjdFVybChhdHRyaWJ1dGlvbik7XG5cbiAgICAgIGlmICghaXNFbXB0eSh1cmwpKSB7XG4gICAgICAgIGJsb2NrcXVvdGVPcGVuLmF0dHJTZXQoJ2NpdGUnLCB1cmwpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgbmV3IHRva2VucyBmb3IgdGhlIGF0dHJpYnV0aW9uIGxpbmUuXG4gICAgICB2YXIgY2FwdGlvbk9wZW4gPSBuZXcgc3RhdGUuVG9rZW4oJ2Jsb2NrcXVvdGVfYXR0cmlidXRpb25fb3BlbicsICdmaWdjYXB0aW9uJywgMSk7XG4gICAgICBjYXB0aW9uT3Blbi5ibG9jayA9IHRydWU7XG4gICAgICBjYXB0aW9uT3Blbi5sZXZlbCA9IGxldmVsICsgMTtcblxuICAgICAgdmFyIGNhcHRpb24gPSBuZXcgc3RhdGUuVG9rZW4oJ2lubGluZScsICcnLCAwKTtcbiAgICAgIGNhcHRpb24uY2hpbGRyZW4gPSBbXTtcbiAgICAgIGNhcHRpb24ubGV2ZWwgPSBsZXZlbCArIDI7XG4gICAgICBjYXB0aW9uLmNvbnRlbnQgPSBvcHRpb25zLnJlbW92ZU1hcmtlclxuICAgICAgICA/IHRyaW1TdGFydChhdHRyaWJ1dGlvbi5zbGljZShvcHRpb25zLm1hcmtlci5sZW5ndGgpKVxuICAgICAgICA6IGF0dHJpYnV0aW9uO1xuXG4gICAgICB2YXIgY2FwdGlvbkNsb3NlID0gbmV3IHN0YXRlLlRva2VuKCdibG9ja3F1b3RlX2F0dHJpYnV0aW9uX2Nsb3NlJywgJ2ZpZ2NhcHRpb24nLCAtMSk7XG4gICAgICBjYXB0aW9uQ2xvc2UuYmxvY2sgPSB0cnVlO1xuICAgICAgY2FwdGlvbkNsb3NlLmxldmVsID0gbGV2ZWwgKyAxO1xuXG4gICAgICBpZiAoIWlzRW1wdHkob3B0aW9ucy5jbGFzc05hbWVBdHRyaWJ1dGlvbikpIHtcbiAgICAgICAgY2FwdGlvbk9wZW4uYXR0clNldCgnY2xhc3MnLCBvcHRpb25zLmNsYXNzTmFtZUF0dHJpYnV0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaW5zZXJ0QXQodG9rZW5zLCBbY2FwdGlvbk9wZW4sIGNhcHRpb24sIGNhcHRpb25DbG9zZV0sIGVuZCArIDEpO1xuXG4gICAgICAvLyBXcmFwIGJsb2NrIHF1b3RlIGFuZCBhdHRyaWJ1dGlvbiBpbiBhIGZpZ3VyZSBlbGVtZW50LlxuICAgICAgdmFyIGZpZ3VyZU9wZW4gPSBuZXcgc3RhdGUuVG9rZW4oJ2Jsb2NrcXVvdGVfY29udGFpbmVyX29wZW4nLCAnZmlndXJlJywgMSk7XG4gICAgICBmaWd1cmVPcGVuLmJsb2NrID0gdHJ1ZTtcbiAgICAgIGZpZ3VyZU9wZW4ubGV2ZWwgPSBsZXZlbDtcblxuICAgICAgdmFyIGZpZ3VyZUNsb3NlID0gbmV3IHN0YXRlLlRva2VuKCdibG9ja3F1b3RlX2NvbnRhaW5lcl9jbG9zZScsICdmaWd1cmUnLCAtMSk7XG4gICAgICBmaWd1cmVDbG9zZS5ibG9jayA9IHRydWU7XG4gICAgICBmaWd1cmVDbG9zZS5sZXZlbCA9IGxldmVsO1xuXG4gICAgICBpZiAoIWlzRW1wdHkob3B0aW9ucy5jbGFzc05hbWVDb250YWluZXIpKSB7XG4gICAgICAgIGZpZ3VyZU9wZW4uYXR0clNldCgnY2xhc3MnLCBvcHRpb25zLmNsYXNzTmFtZUNvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIGluc2VydEF0KHRva2VucywgW2ZpZ3VyZUNsb3NlXSwgZW5kICsgNCk7XG4gICAgICBpbnNlcnRBdCh0b2tlbnMsIFtmaWd1cmVPcGVuXSwgc3RhcnQpO1xuXG4gICAgICAvLyBTa2lwIHRoZSBnZW5lcmF0ZWQgYmxvY2sgcXVvdGUgdG9rZW5zIGluIHRoZSBzdHJlYW0uXG4gICAgICBpID0gZW5kICsgNTtcbiAgICB9XG4gIH1cblxuICBtZC5jb3JlLnJ1bGVyLmFmdGVyKCdibG9jaycsICdhdHRyaWJ1dGlvbicsIHJ1bGUpO1xufTtcbiJdfQ=="}